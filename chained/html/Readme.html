<h3 id='what_is_chained'>What is Chained</h3>

<p><strong>Chained</strong> is an experiment and a prototype library for Javascript. It is meant to show a concept and to provide some limited but useful functionality. All the examples below are written in Coffeescript (and I guess that this makes me a hippie, right?).</p>

<p><strong>Chained</strong> allows to chain functions explicitly — both those that return promises and those who don&#8217;t — without using <code>then</code>-based constructs.</p>

<p>For example, here&#8217;s how you could create a chained computation that:</p>

<ul>
<li>downloads with jQuery&#8217;s <code>get</code> a user&#8217;s <code>npm</code> page</li>

<li>filters the links to his projects with underscore</li>

<li>prints the links</li>
</ul>

<p>(hover above the underlined elements for additional info)</p>

<pre><code>jQuery       = require(&#39;jQuery&#39;)
underscore   = require(&#39;underscore&#39;)
string       = require(&#39;underscore.string&#39;)
linklib      = require(&#39;linklib&#39;)
{ using, _ } = require(&#39;./chain&#39;).chain.init()

using(jQuery)
using(underscore)
using(string)
using(console)
using(linklib)

getUser = (user) -&gt;
      _(&quot;https://npmjs.org/~#{user}&quot;)
        .get()
        .extractLinks()
        .filter( -&gt; /package/.test(arguments[0]) )
        .map( -&gt; &quot;https://npmjs.org#{arguments[0]}&quot; )
        .log()

getUser(&quot;vzaccaria&quot;)</code></pre>

<p>Here, we have chained together promise-based functions (like <code>get</code> from <code>jQuery</code>) and normal functions with additional parameters (like <code>map</code> and <code>filter</code> from <code>underscore</code>). All function invocations receive an implicit argument that is the value computed by the previous link in the chain.</p>

<p>The function defined in <code>getUser</code> implements a processing pipeline (à la <em>streaming</em>). It starts with the link to be retrieved by specifying it with <code>_()</code>:</p>

<pre><code>_(&quot;https://npmjs.org/~#{user}&quot;)</code></pre>

<p>this value is then passed to <code>get()</code> of <code>jQuery</code>. <strong>Chained</strong> knows that <code>jQuery</code> has a <code>get</code> method since we introduced its scope with</p>

<pre><code>using(jQuery) </code></pre>

<p>at the beginning<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>The result of <code>get()</code> — i.e. the webpage — is sent to <code>extractLinks</code> (from <code>linklib</code>) when the associated promise is resolved. The rest of the computation proceeds as you can intuitively imagine.</p>

<p>If an exception is thrown in any of the links of the processing chain then the following links are not executed, just as you would expect from promises.</p>

<p>We can add additional arguments (besides the implicit one) to method invocations; for example the <code>filter</code> function (from <code>underscore</code>) is invoked as:</p>

<pre><code>…
.filter( -&gt; /package/.test(arguments[0]) )
…</code></pre>

<p>where the <em>lambda</em> function is passed effectively as the second parameter to <code>underscore.filter</code> (the first being the implicit parameter).</p>

<p>So we nailed a few things here:</p>

<ul>
<li>We can chain promise-based functions and normal functions without distinction using the natural syntax of Javascript.</li>

<li>We can use directly their names instead of using <code>then</code>.</li>

<li>We can chain <strong>any method</strong> from an arbitrary number of modules, provided that the module is bound to <strong>Chained</strong> with the <code>using</code> clause.</li>

<li>We don&#8217;t modify dynamically the module that are imported. We don&#8217;t change any prototype.</li>

<li>The chain stops executing when one of the links throws an exception or a promise is rejected.</li>

<li>We are not using any coffee-script mambo-jumbo for chaining; we can write with the same expressiveness in pure Javascript.</li>
</ul>
<hr />
<h3 id='wheres_the_catch'>Where&#8217;s the catch?</h3>

<p>We are exploiting ECMA6/harmony implementation of <strong>introspection</strong>. You need an ECMA6/harmony implementation, either in node (<code>node --harmony</code>) or in your browser (Firefox is ok at the moment) to make it work.</p>
<hr />
<h3 id='does_it_work_in_the_browser'>Does it work in the browser?</h3>

<p>Yes, check out this example <a href='demo.html'>Domain Specific Language for form validation</a> directly built with Chained. <strong>Warning: it needs a recent build of Firefox. In principle also a harmony-enabled Chrome should work, but I did not try it</strong>.</p>
<hr />
<h3 id='how_to_install_it'>How to install it?</h3>

<p>On node:</p>

<pre><code>npm install chained</code></pre>

<p>In the browser, download it from Github and include these files:</p>

<ul>
<li><code>reflect.js</code></li>

<li><code>dsl.js</code>,</li>

<li><code>chain.js</code></li>
</ul>

<p>You should be good to go.</p>
<hr />
<h3 id='implementation'>Implementation</h3>

<p>The idea for <strong>Chained</strong> came while tinkering with <strong>domain specific languages</strong>. DSLs provide the developer with the vocabulary of a problem domain to express a programmatic solution that could be understood by a <em>problem domain expert</em><sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>I will not cover all the general concepts of DSLs here. For an in depth overview, I&#8217;d suggest to look at these resources:</p>

<ul>
<li><a href='http://www.amazon.com/DSLs-Action-Debasish-Ghosh/dp/1935182455'>Debasish Ghosh, &#8220;DSLs in Action&#8221;</a> — Manning Publications Co.</li>

<li><a href='http://martinfowler.com/books/dsl.html'>Martin Fowler Website</a> (and <a href='http://www.amazon.com/gp/product/0321712943?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321712943'>book</a>)</li>

<li><a href='http://docs.codehaus.org/display/GROOVY/Writing+Domain-Specific+Languages'>Writing Domain Specific Languages</a> — Groovy website.</li>

<li><a href='http://www.cas.mcmaster.ca/~carette/publications/FedorenkoThesis.pdf'>Validation DSL for Client-Server Applications</a> — Vitalii Fedorenko Master Thesis</li>

<li><a href='http://webdsl.org/home'>WebDSL</a></li>
</ul>

<p><strong>Internal DSLs</strong> are built using the syntactic and semantic features of another language; they are used in the context of a broader application for which they address a narrow but important problem.</p>

<p>My quest was to find a way to implement a DSL in Javascript. Let&#8217;s see what features are needed by a general purpose language like Javascript to support the definition of internal DSLs:</p>

<ul>
<li>
<p>Support for named arguments (or hashes) in function invocation (aka <em>Smart API</em>), e.g.:</p>

<pre><code>  move(the: pen, on: theTable)</code></pre>
</li>

<li>
<p>Support for a <em>property/method missing exception</em> to implement method chaining:</p>

<pre><code>  take(&#39;spaghetti&#39;).and().cookIt(at: 100C)</code></pre>

<p>here <code>and</code> is a non existing method of the return value <code>V</code> of <code>take(&#39;spaghetti&#39;)</code>. The missing exception handler will return the same value <code>V</code> so that <code>cookIt</code> could be called on it.</p>
</li>

<li>
<p>(optional, but highly desirable)</p>

<p>- Reduced boilerplate code.</p>

<p>- Synthetic expression of closures (w/ implicit arguments).</p>

<p>- Limited presence of parenthesis <code>{}</code> and <code>()</code>:</p>

<pre><code>    withObject chair, -&gt;
        move it, in: theLivingRoom</code></pre>
</li>
</ul>

<p>At some point, it became clear to me that DSLs&#8217; <em>method chaining</em> can be used to implicitly structure promise based chains. In fact, you could build a promise-chain by handling a sequence of method missing exceptions.</p>

<p>As a byproduct, it is straightforward to use the same technique to chain normal functions, without any exogenous construct like <code>then</code>.</p>

<h4 id='the_roadblocks'>The roadblocks</h4>

<p>Javascript and its relatives (such as Coffee and LiveScript) have almost all the characteristics to build a sophisticated DSL. The only problem is that they lack of a <strong>method missing exception</strong>; at least until Harmony came out.</p>

<p><a href='http://unobfuscated.blogspot.it/2012/06/creating-catchall-method-for-javascript.html'>Dylan Barrell already demonstrated</a> that with the new <strong>reflection</strong> API, it is possible to manage missing methods. His technique exploits the concept of <strong>Proxies</strong>. Think about a Proxy like a wrapper around your original object that is able to intercept calls to methods that are not defined. <strong>Chained</strong> is based on Dylan&#8217;s work.</p>

<h4 id='the_basic_idea'>The basic idea</h4>

<p>The basic idea goes as follows:</p>

<ol>
<li>
<p>We create an object that can handle missing methods <a href='http://unobfuscated.blogspot.it/2012/06/creating-catchall-method-for-javascript.html'>through an appropriate mechanism</a>. Let&#8217;s call it <code>o</code>.</p>
</li>

<li>
<p><code>o</code> contains a <code>promise</code> property. Whenever a method missing is invoked on <code>o</code>:</p>

<pre><code>o.m()</code></pre>

<p>we catch it and handle it with the following handler:</p>

<pre><code>handleMethodMissing = (m) -&gt; 
     this.promise = this.promise.then( (it) -&gt; scope[m](it) )
     return this</code></pre>

<p>now, note that:</p>

<ul>
<li>we need a scope in which to look for <code>m</code>. In <strong>Chained</strong>, we use <code>using(module)</code> to specify/extend this scope.</li>

<li><code>m</code> is called with the final value of the previous promise.</li>

<li>even if <code>m</code> returns a new promise, this is perfectly fine since the <code>then</code> method is going to resolve the original <code>o.promise</code> accordingly.</li>

<li>we return <code>o</code>, so that we can repeat the same process by seemingly chaining methods that are effectively missing.</li>
</ul>
</li>

<li>
<p>We need a way to fire the very first promise off. In <strong>Chained</strong>, we use the function <code>_()</code> both for creating <code>o</code> and to resolve the first promise of the chain with the value passed to it:</p>

<pre><code>_(v) = -&gt; 
     o = new methodMissingObject()
     o.deferred = defer()
     o.promise = o.deferred.promise
     o.deferred.resolve(v)
     return o</code></pre>
</li>
</ol>

<h3 id='api'>API</h3>

<p>The API is pretty simple at the moment; however, I think it offers a good level of flexibility to be leveraged.</p>

<dl>
<dt><code>chain.using(module)</code></dt>

<dd>
<p>Extends the scope within which all missing methods are searched for. You can include multiple modules:</p>

<pre><code>    using(jQuery)
    using(underscore)</code></pre>
</dd>

<dt><code>o = chain._(value)</code></dt>

<dd>
<p>returns a deferred object whose <code>promise</code> property will eventually be resolved to <code>value</code>. The object handles missing methods by chaining them using <code>Q</code>.</p>
</dd>
</dl>

<h4 id='deferred_object_methods_and_properties'>Deferred object methods and properties</h4>

<p>Given the deferred object <code>o</code>, the following methods apply; remember that they return again a deferred object:</p>

<dl>
<dt><code>o.foo(...)</code></dt>

<dd>if <code>o</code> eventually resolves to <code>v</code>, this is essentially equivalent to building a <em>deferred</em> <code>foo(v, ...)</code>.</dd>

<dt><code>o._(foo)</code></dt>

<dd>specify a one shot function <code>foo</code> to be chained with the rest, without extending the scope with <code>using</code>.</dd>

<dt><code>o._forEach(bar)</code></dt>

<dd>if <code>o</code> will eventually resolve to an array, apply <code>bar</code> to each element; the combined promise is created with <code>Q.all</code>.</dd>

<dt><code>o.promise</code></dt>

<dd>this is a Q promise corresponding to the deferred <code>o</code>.</dd>
</dl>

<p><strong>New</strong>:</p>

<dl>
<dt><code>o.nFoo</code></dt>

<dd>
<p>as <code>o.foo</code> but treats <code>foo</code> as a node-style async function (i.e., callback are assumed to be in the form <code>(err, res) -&gt;</code> ). Example:</p>

<pre><code>using(fs)
_(&quot;./src/form.ls&quot;).nReadFile(&#39;utf-8&#39;).promise.then( -&gt; done() )</code></pre>
</dd>

<dt><code>o.thenFoo</code>:</dt>

<dd>
<p>when <code>o</code> eventually resolves, this is essentially equivalent to building a <em>deferred</em> <code>foo(...)</code>.</p>

<pre><code>using(console)
_(&#39;Just&#39;).log().thenLog(&quot;a&quot;).thenLog(&quot;sequence&quot;).thenLog(&quot;of&quot;).thenLog(&quot;strings&quot;).</code></pre>
</dd>
</dl>

<h3 id='history'>History</h3>

<ul>
<li>11-22-2013: * Added support for node-style invocation of callbacks (using <code>Q.nfapply</code>) * Added support for plain sequential invocation of functions without passing input values</li>

<li>11-05-2013 * Original release</li>
</ul>

<h3 id='tests'>Tests</h3>

<p>23 passing tests, just run them with:</p>

<pre><code>npm tests</code></pre>

<h3 id='license'>License</h3>

<p>MIT</p>
<div class='footnotes'><hr /><ol><li id='fn:1'>
<p>The <code>using</code> clause extends the scope within which <strong>Chained</strong> looks for functions to be chained.</p>
<a href='#fnref:1' rev='footnote'>&#8617;</a></li><li id='fn:2'>
<p>Make, SQL, CSS are all famous examples of DSLs widely used by developers.</p>
<a href='#fnref:2' rev='footnote'>&#8617;</a></li></ol></div>
